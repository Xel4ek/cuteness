(()=>{"use strict";class C{constructor(t,n=0,o={rows:Array.from({length:t.length}).map((l,d)=>d),cols:Array.from({length:t.length}).map((l,d)=>d)},i=[]){this.matrix=t,this.lowerBound=n,this.indexes=o,this.path=i}compareTo(t){return this.lowerBound-t.lowerBound}blockPath(t,n){const o=this.indexes.rows.indexOf(t),i=this.indexes.cols.indexOf(n);-1!==i&&-1!==o&&(this.matrix[o][i]=1/0)}dryReduceMatrix(t,n,o){this.blockPath(t,n),this.lowerBound+=o;const{matrix:i}=this.reduceMatrix(this.matrix);this.matrix=i}transform(t,n){const o=this.indexes.rows.indexOf(t),i=this.indexes.cols.indexOf(n),l=this.matrix.map(y=>[...y]),d=this.indexes.cols.indexOf(t),c=this.indexes.rows.indexOf(n);-1!==d&&-1!==c&&(l[c][d]=1/0);const m=l.filter((y,w)=>w!==o).map(y=>y.filter((w,b)=>b!==i)),{matrix:M,lowerBound:A}=this.reduceMatrix(m);return new C(M,this.lowerBound+A,{rows:this.indexes.rows.filter((y,w)=>w!==o),cols:this.indexes.cols.filter((y,w)=>w!==i)},[...this.path,[t,n]])}calculatePenalties(){let n,t=-1/0;const o=Array(this.matrix.length).fill(0).map(()=>Array(this.matrix.length).fill(0));for(let i=0;i<this.matrix.length;i++)for(let l=0;l<this.matrix[i].length;l++)if(0===this.matrix[i][l]){const d=Math.min(...this.matrix[i].filter((m,M)=>M!==l&&m!==1/0)),c=Math.min(...this.matrix.map((m,M)=>M!==i&&m[l]!==1/0?m[l]:1/0));o[i][l]=d+c,o[i][l]>=t&&(t=o[i][l],n=[i,l])}return n?{penalty:t,maxPenaltyPos:[this.indexes.rows[n[0]],this.indexes.cols[n[1]]]}:{penalty:-1,maxPenaltyPos:[-1,-1]}}reduceMatrix(t){const n=this.rowReduction(t),o=this.columnReduction(n.matrix);return{matrix:o.matrix,lowerBound:[...n.redux,...o.redux].reduce((i,l)=>i+l,0)}}rowReduction(t){const n=[],o=t.map(i=>{const l=Math.min(...i);return n.push(l),i.map(d=>d!==1/0?d-l:d)});return{redux:n,matrix:o}}columnReduction(t){const n=t.map((l,d)=>t.map(c=>c[d])),o=this.rowReduction(n),i=o.matrix[0].map((l,d)=>o.matrix.map(c=>c[d]));return{redux:o.redux,matrix:i}}restorePath(){const t=[],n=[...this.path];let o=n.shift()??[-1,-1];for(t.push(o[0]);n.length>0;){const i=n.findIndex(l=>l[0]===o[1]);if(-1===i)break;o=n[i],n.splice(i,1),t.push(o[0])}return t.push(o[1]),t}}class O{constructor(t){this.value=t,this.left=null,this.right=null,this.npl=0}compareTo(t){return this.value.compareTo(t.value)}}class F{constructor(){this.root=null}enqueue(t){this.root=this.merge(this.root,new O(t))}dequeue(){if(!this.root)return;const t=this.root.value;return this.root=this.merge(this.root.left,this.root.right),t}isEmpty(){return null===this.root}merge(t,n){return t?(n&&(t.compareTo(n)>0&&([t,n]=[n,t]),t.right=this.merge(t.right,n),(!t.left||t.right&&t.left.npl<t.right.npl)&&([t.left,t.right]=[t.right,t.left]),t.npl=t.right?t.right.npl+1:1),t):n}}class T{static solveTravelingSalesmanProblemACO(t){const n=10*t.length,M=t.map(s=>s.map(r=>0===r?1/0:r)),A=1/(t.length*t.length),y=t.reduce((s,r)=>s+r.reduce((u,e)=>u+e,0),0),w=t.map(s=>s.map(r=>A/y*r)),b=(s,r)=>M[s][r];let P=1/0,I=[],k=[],S=0;for(let s=0;s<1e4;s++){const r=Array.from({length:n},()=>({path:[0],currentNode:0,cost:0}));if(r.forEach(e=>{S++;const a=new Set(e.path);for(;a.size<t.length;){const x=t[e.currentNode].map((f,g)=>g).filter(f=>!a.has(f)&&b(e.currentNode,f)),h=x.reduce((f,g)=>f+Math.pow(w[e.currentNode][g],1)*Math.pow(1/b(e.currentNode,g),1),0),p=x.map(f=>({dest:f,prob:Math.pow(w[e.currentNode][f],1)*Math.pow(1/b(e.currentNode,f),1)/h}));p.sort((f,g)=>g.prob-f.prob);const _=Math.random();let N=0,v=-1;for(const f of p)if(N+=f.prob,N>=_){v=f.dest;break}if(-1===v)break;e.path.push(v),e.currentNode=v,a.add(v),e.cost+=b(e.path[e.path.length-2],e.currentNode)}e.cost+=b(e.currentNode,0),e.cost<P&&e.path.length===t.length&&(P=e.cost,I=[...e.path,0])}),s%50==0&&k.toString()===I.toString()&&P<1/0)return{vertices:I,distance:P,paths:S};const u=r.map(e=>{const a=e.path,x=e.cost,h=Array.from({length:t.length},()=>0);for(let p=0;p<a.length-1;p++){const N=a[p+1];h[a[p]]+=100/x,h[N]+=100/x}return h});for(let e=0;e<t.length;e++)for(let a=0;a<t.length;a++)e!==a&&(w[e][a]=.5*w[e][a]+u[e][a]);k=I}return I.length===t.length&&isFinite(P)?{vertices:I,distance:P,paths:S}:null}static solveTravelingSalesmanProblemGA(t){const n=t.length,o=20*n,i=Math.trunc(1e5/n),l=Math.trunc(.1*o),c=t.map(s=>s.map(r=>0===r?1/0:r)),m=s=>{let r=0,u=0;for(let e=0;e<s.length;e++){const a=c[s[e]][s[(e+1)%s.length]];isFinite(1/0)||++r,u+=a}return 1/u/(r+1)},M=(s,r)=>{const u=[...s];if(Math.random()<r){let e=Math.floor(Math.random()*u.length),a=Math.floor(Math.random()*u.length);for(;e===a;)a=Math.floor(Math.random()*u.length);for(a<e&&([e,a]=[a,e]);e<a;)[u[e],u[a]]=[u[a],u[e]],e++,a--}return u},A=(s,r)=>{const u=s.length,e=new Array(u).fill(-1),a=Math.floor(Math.random()*u),x=a+Math.floor(Math.random()*(u-a));for(let h=a;h<=x;h++)e[h]=s[h];for(let h=0;h<u;h++)if(!e.includes(r[h])){let p=h;for(;-1!==e[p];)p=s.indexOf(r[p]);e[p]=r[h]}return e};let y=Array.from({length:o},()=>{const s=Array.from({length:n},(r,u)=>u);for(let r=s.length-1;r>0;r--){const u=Math.floor(Math.random()*(r+1));[s[r],s[u]]=[s[u],s[r]]}return s}),w=0,b=[],P=-1/0,I=0;for(let s=0;s<i;s++){let r=-1/0;y.sort((x,h)=>m(h)-m(x)),I+=y.length;const u=y.slice(0,l),e=[...u],a=(x,h)=>{const p=x.reduce((g,B)=>g+h(B),0),_=Math.random()*p;let v,f,N=0;for(const g of x)if(N+=h(g),!v&&N>=_)v=g;else if(v&&!f&&N>=_){f=g;break}if(!f){const g=x.filter(j=>j!==v);f=g[Math.floor(Math.random()*g.length)]}return[v,f]};for(let x=0;x<o-l;x++){let h=A(...a(u,m));h=M(h,.05),e.push(h);const p=m(h);p>r&&(r=p,b=h)}if(y=e,r>P)P=r,w=0;else if(r>0&&w++>=5)break}const S=(s=b).reduce((r,u,e)=>r+c[u][s[(e+1)%c.length]],0);var s;return isFinite(S)?{vertices:[...b,b[0]],distance:S,paths:I}:null}static solveTravelingSalesmanProblemLittle(t){const n=new C(t.map(c=>c.map(m=>0===m?1/0:m))),o=new F,{matrix:i,lowerBound:l}=n.reduceMatrix(n.matrix);let d=0;for(o.enqueue(new C(i,l));!o.isEmpty();){const c=o.dequeue();if(!c)return null;if(1===c.matrix.length){if(c.path.push([c.indexes.rows[0],c.indexes.cols[0]]),c.lowerBound===1/0)return null;const m=c.restorePath();if(m.length===t.length+1)return{vertices:m,distance:c.lowerBound,paths:d}}else{const{penalty:m,maxPenaltyPos:[M,A]}=c.calculatePenalties();if(-1===m)return null;o.enqueue(c.transform(M,A)),m!==1/0&&(c.dryReduceMatrix(M,A,m),o.enqueue(c))}d++}return null}}const q={Ants:T.solveTravelingSalesmanProblemACO,Genetic:T.solveTravelingSalesmanProblemGA,Little:T.solveTravelingSalesmanProblemLittle};self.onmessage=({data:R})=>{const{method:t,adjacencyMatrix:n}=R,o=q[t];if(o){const i=performance.now(),l=o(n),c=performance.now()-i;self.postMessage({solution:l,timeElapsed:c})}else console.error(`Unknown method: ${t}`)}})();