(()=>{"use strict";class C{constructor(t,i=0,l={rows:Array.from({length:t.length}).map((c,d)=>d),cols:Array.from({length:t.length}).map((c,d)=>d)},n=[]){this.matrix=t,this.lowerBound=i,this.indexes=l,this.path=n}compareTo(t){return this.lowerBound-t.lowerBound}blockPath(t,i){const l=this.indexes.rows.indexOf(t),n=this.indexes.cols.indexOf(i);-1!==n&&-1!==l&&(this.matrix[l][n]=1/0)}dryReduceMatrix(){const{matrix:t}=this.reduceMatrix(this.matrix);this.matrix=t}transform(t,i){const l=this.indexes.rows.indexOf(t),n=this.indexes.cols.indexOf(i),c=this.matrix.map(m=>[...m]),d=this.indexes.cols.indexOf(t),x=this.indexes.rows.indexOf(i);-1!==d&&-1!==x&&(c[x][d]=1/0);const s=c.filter((m,g)=>g!==l).map(m=>m.filter((g,v)=>v!==n)),{matrix:f,lowerBound:b}=this.reduceMatrix(s);return new C(f,this.lowerBound+b,{rows:this.indexes.rows.filter((m,g)=>g!==l),cols:this.indexes.cols.filter((m,g)=>g!==n)},[...this.path,[t,i]])}calculatePenalties(){let i,t=-1/0;const l=Array(this.matrix.length).fill(0).map(()=>Array(this.matrix.length).fill(0));for(let n=0;n<this.matrix.length;n++)for(let c=0;c<this.matrix[n].length;c++)if(0===this.matrix[n][c]){const d=Math.min(...this.matrix[n].filter((s,f)=>f!==c&&s!==1/0)),x=Math.min(...this.matrix.map((s,f)=>f!==n&&s[c]!==1/0?s[c]:1/0));l[n][c]=d+x,l[n][c]>=t&&(t=l[n][c],i=[n,c])}return i?{penalty:t,maxPenaltyPos:[this.indexes.rows[i[0]],this.indexes.cols[i[1]]]}:{penalty:-1,maxPenaltyPos:[-1,-1]}}reduceMatrix(t){const i=this.rowReduction(t),l=this.columnReduction(i.matrix);return{matrix:l.matrix,lowerBound:[...i.redux,...l.redux].reduce((n,c)=>n+c,0)}}rowReduction(t){const i=[],l=t.map(n=>{const c=Math.min(...n);return i.push(c),n.map(d=>d!==1/0?d-c:d)});return{redux:i,matrix:l}}columnReduction(t){const i=t.map((c,d)=>t.map(x=>x[d])),l=this.rowReduction(i),n=l.matrix[0].map((c,d)=>l.matrix.map(x=>x[d]));return{redux:l.redux,matrix:n}}}class O{constructor(t){this.value=t,this.left=null,this.npl=0,this.right=null}compareTo(t){return this.value.compareTo(t.value)}}class F{constructor(){this.size=0,this.root=null}enqueue(t){this.size++,this.root=this.merge(this.root,new O(t))}dequeue(){if(!this.root)return;const t=this.root;return this.root=this.merge(this.root.left,this.root.right),t.left=null,t.right=null,t.value}isEmpty(){return null===this.root}merge(t,i){return t?(i&&(t.compareTo(i)>0&&([t,i]=[i,t]),t.right=this.merge(t.right,i),(!t.left||t.right&&t.left.npl<t.right.npl)&&([t.left,t.right]=[t.right,t.left]),t.npl=t.right?t.right.npl+1:1),t):i}}class T{static solveTravelingSalesmanProblemACO(t){const i=10*t.length,f=t.map(r=>r.map(o=>0===o?1/0:o)),b=1/(t.length*t.length),m=t.reduce((r,o)=>r+o.reduce((u,e)=>u+e,0),0),g=t.map(r=>r.map(o=>b/m*o)),v=(r,o)=>f[r][o];let I=1/0,A=[],k=[],N=0;for(let r=0;r<1e4;r++){const o=Array.from({length:i},()=>({path:[0],currentNode:0,cost:0}));if(o.forEach(e=>{N++;const a=new Set(e.path);for(;a.size<t.length;){const y=t[e.currentNode].map((p,M)=>M).filter(p=>!a.has(p)&&v(e.currentNode,p)),h=y.reduce((p,M)=>p+Math.pow(g[e.currentNode][M],1)*Math.pow(1/v(e.currentNode,M),1),0),w=y.map(p=>({dest:p,prob:Math.pow(g[e.currentNode][p],1)*Math.pow(1/v(e.currentNode,p),1)/h}));w.sort((p,M)=>M.prob-p.prob);const _=Math.random();let S=0,P=-1;for(const p of w)if(S+=p.prob,S>=_){P=p.dest;break}if(-1===P)break;e.path.push(P),e.currentNode=P,a.add(P),e.cost+=v(e.path[e.path.length-2],e.currentNode)}e.cost+=v(e.currentNode,0),e.cost<I&&e.path.length===t.length&&(I=e.cost,A=[...e.path,0])}),r%50==0&&k.toString()===A.toString()&&I<1/0)return{vertices:A,distance:I,paths:N};const u=o.map(e=>{const a=e.path,y=e.cost,h=Array.from({length:t.length},()=>0);for(let w=0;w<a.length-1;w++){const S=a[w+1];h[a[w]]+=100/y,h[S]+=100/y}return h});for(let e=0;e<t.length;e++)for(let a=0;a<t.length;a++)e!==a&&(g[e][a]=.5*g[e][a]+u[e][a]);k=A}return A.length===t.length&&isFinite(I)?{vertices:A,distance:I,paths:N}:null}static solveTravelingSalesmanProblemGA(t){const i=t.length,l=20*i,n=Math.trunc(1e5/i),c=Math.trunc(.1*l),x=t.map(r=>r.map(o=>0===o?1/0:o)),s=r=>{let o=0,u=0;for(let e=0;e<r.length;e++){const a=x[r[e]][r[(e+1)%r.length]];isFinite(1/0)||++o,u+=a}return 1/u/(o+1)},f=(r,o)=>{const u=[...r];if(Math.random()<o){let e=Math.floor(Math.random()*u.length),a=Math.floor(Math.random()*u.length);for(;e===a;)a=Math.floor(Math.random()*u.length);for(a<e&&([e,a]=[a,e]);e<a;)[u[e],u[a]]=[u[a],u[e]],e++,a--}return u},b=(r,o)=>{const u=r.length,e=new Array(u).fill(-1),a=Math.floor(Math.random()*u),y=a+Math.floor(Math.random()*(u-a));for(let h=a;h<=y;h++)e[h]=r[h];for(let h=0;h<u;h++)if(!e.includes(o[h])){let w=h;for(;-1!==e[w];)w=r.indexOf(o[w]);e[w]=o[h]}return e};let m=Array.from({length:l},()=>{const r=Array.from({length:i},(o,u)=>u);for(let o=r.length-1;o>0;o--){const u=Math.floor(Math.random()*(o+1));[r[o],r[u]]=[r[u],r[o]]}return r}),g=0,v=[],I=-1/0,A=0;for(let r=0;r<n;r++){let o=-1/0;m.sort((y,h)=>s(h)-s(y)),A+=m.length;const u=m.slice(0,c),e=[...u],a=(y,h)=>{const w=y.reduce((M,B)=>M+h(B),0),_=Math.random()*w;let P,p,S=0;for(const M of y)if(S+=h(M),!P&&S>=_)P=M;else if(P&&!p&&S>=_){p=M;break}if(!p){const M=y.filter(j=>j!==P);p=M[Math.floor(Math.random()*M.length)]}return[P,p]};for(let y=0;y<l-c;y++){let h=b(...a(u,s));h=f(h,.05),e.push(h);const w=s(h);w>o&&(o=w,v=h)}if(m=e,o>I)I=o,g=0;else if(o>0&&g++>=5)break}const N=(r=v).reduce((o,u,e)=>o+x[u][r[(e+1)%x.length]],0);var r;return isFinite(N)?{vertices:[...v,v[0]],distance:N,paths:A}:null}static solveTravelingSalesmanProblemLittle(t){function i(s){const f=[];let b=s.shift()??[-1,-1];for(f.push(b[0]);s.length>0;){const m=s.findIndex(g=>g[0]===b[1]);if(-1===m)break;b=s[m],s.splice(m,1),f.push(b[0])}return f.push(b[1]),f}const l=new C(t.map(s=>s.map(f=>0===f?1/0:f))),n=new F,{matrix:c,lowerBound:d}=l.reduceMatrix(l.matrix);let x=0;for(n.enqueue(new C(c,d));!n.isEmpty();){const s=n.dequeue();if(!s)return null;if(1===s.matrix.length){if(s.path.push([s.indexes.rows[0],s.indexes.cols[0]]),s.lowerBound===1/0)return null;const f=i(s.path);if(f.length!==t.length+1)continue;return{vertices:f,distance:s.lowerBound,paths:x}}{const{penalty:f,maxPenaltyPos:[b,m]}=s.calculatePenalties();if(-1===f)return null;const g=s.transform(b,m);n.enqueue(g),f!==1/0&&(s.blockPath(b,m),s.lowerBound+=f,s.dryReduceMatrix(),n.enqueue(s))}x++}return null}}const q={Ants:T.solveTravelingSalesmanProblemACO,Genetic:T.solveTravelingSalesmanProblemGA,Little:T.solveTravelingSalesmanProblemLittle};self.onmessage=({data:R})=>{const{method:t,adjacencyMatrix:i}=R,l=q[t];if(l){const n=performance.now(),c=l(i),x=performance.now()-n;self.postMessage({solution:c,timeElapsed:x})}else console.error(`Unknown method: ${t}`)}})();