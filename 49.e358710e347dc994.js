(()=>{"use strict";class C{constructor(t,i,s){this.route=t,this.distance=i,this.bitmask=s,this.left=null,this.right=null,this.npl=0}compareTo(t){return this.distance!==t.distance?this.distance-t.distance:t.route.length-this.route.length}}class R{constructor(t,i){this.vertices=t,this.distance=i,this.left=null,this.right=null,this.npl=0}compareTo(t){return this.distance!==t.distance?this.distance-t.distance:t.vertices.length-this.vertices.length}}class F{constructor(){this.size=0,this.root=null}enqueue(t){this.size++,this.root=this.merge(this.root,t)}dequeue(){if(!this.root)return;const t=this.root;return this.root=this.merge(this.root.left,this.root.right),t.left=null,t.right=null,t}isEmpty(){return null===this.root}merge(t,i){return t?(i&&(t.compareTo(i)>0&&([t,i]=[i,t]),t.right=this.merge(t.right,i),(!t.left||t.right&&t.left.npl<t.right.npl)&&([t.left,t.right]=[t.right,t.left]),t.npl=t.right?t.right.npl+1:1),t):i}}class k{constructor(t,i=0,s={rows:Array.from({length:t.length}).map((l,m)=>m),cols:Array.from({length:t.length}).map((l,m)=>m)},o=[]){this.matrix=t,this.lowerBound=i,this.indexes=s,this.path=o}blockPath(t,i){const s=this.indexes.rows.indexOf(t),o=this.indexes.cols.indexOf(i);-1!==o&&-1!==s&&(this.matrix[s][o]=1/0)}dryReduceMatrix(){const{matrix:t}=this.reduceMatrix(this.matrix);this.matrix=t}transform(t,i){const s=this.indexes.rows.indexOf(t),o=this.indexes.cols.indexOf(i),l=this.matrix.map(g=>[...g]),m=this.indexes.cols.indexOf(t),n=this.indexes.rows.indexOf(i);-1!==m&&-1!==n&&(l[n][m]=1/0);const e=l.filter((g,p)=>p!==s).map(g=>g.filter((p,b)=>b!==o)),{matrix:h,lowerBound:v}=this.reduceMatrix(e);return new k(h,this.lowerBound+v,{rows:this.indexes.rows.filter((g,p)=>p!==s),cols:this.indexes.cols.filter((g,p)=>p!==o)},[...this.path,[t,i]])}calculatePenalties(){let i,t=-1/0;const s=Array(this.matrix.length).fill(0).map(()=>Array(this.matrix.length).fill(0));for(let o=0;o<this.matrix.length;o++)for(let l=0;l<this.matrix[o].length;l++)if(0===this.matrix[o][l]){const m=Math.min(...this.matrix[o].filter((e,h)=>h!==l&&e!==1/0)),n=Math.min(...this.matrix.map((e,h)=>h!==o&&e[l]!==1/0?e[l]:1/0));s[o][l]=m+n,s[o][l]>=t&&(t=s[o][l],i=[o,l])}return i?{penalty:t,maxPenaltyPos:[this.indexes.rows[i[0]],this.indexes.cols[i[1]]]}:{penalty:-1,maxPenaltyPos:[-1,-1]}}reduceMatrix(t){const i=this.rowReduction(t),s=this.columnReduction(i.matrix);return{matrix:s.matrix,lowerBound:[...i.redux,...s.redux].reduce((o,l)=>o+l,0)}}rowReduction(t){const i=[],s=t.map(o=>{const l=Math.min(...o);return i.push(l),o.map(m=>m!==1/0?m-l:m)});return{redux:i,matrix:s}}columnReduction(t){const i=t.map((l,m)=>t.map(n=>n[m])),s=this.rowReduction(i),o=s.matrix[0].map((l,m)=>s.matrix.map(n=>n[m]));return{redux:s.redux,matrix:o}}}class O{constructor(t){this.value=t,this.left=null,this.npl=0,this.right=null}compareTo(t){return this.value.lowerBound-t.value.lowerBound}}class E{constructor(){this.size=0,this.root=null}enqueue(t){this.size++,this.root=this.merge(this.root,new O(t))}dequeue(){if(!this.root)return;const t=this.root;return this.root=this.merge(this.root.left,this.root.right),t.left=null,t.right=null,t.value}isEmpty(){return null===this.root}merge(t,i){return t?(i&&(t.compareTo(i)>0&&([t,i]=[i,t]),t.right=this.merge(t.right,i),(!t.left||t.right&&t.left.npl<t.right.npl)&&([t.left,t.right]=[t.right,t.left]),t.npl=t.right?t.right.npl+1:1),t):i}}class T{static solveTravelingSalesmanProblemACO(t){const h=t.map(c=>c.map(a=>0===a?1/0:a)),v=1/(t.length*t.length),g=t.reduce((c,a)=>c+a.reduce((d,r)=>d+r,0),0),p=t.map(c=>c.map(a=>v/g*a)),b=(c,a)=>h[c][a];let I=1/0,S=[],_=[],N=0;for(let c=0;c<1e4;c++){const a=Array.from({length:100},()=>({path:[0],currentNode:0,cost:0}));if(a.forEach(r=>{N++;const u=new Set(r.path);for(;u.size<t.length;){const y=t[r.currentNode].map((x,M)=>M).filter(x=>!u.has(x)&&b(r.currentNode,x)),f=y.reduce((x,M)=>x+Math.pow(p[r.currentNode][M],1)*Math.pow(1/b(r.currentNode,M),1),0),w=y.map(x=>({dest:x,prob:Math.pow(p[r.currentNode][x],1)*Math.pow(1/b(r.currentNode,x),1)/f}));w.sort((x,M)=>M.prob-x.prob);const A=Math.random();let B=0,P=-1;for(const x of w)if(B+=x.prob,B>=A){P=x.dest;break}if(-1===P)break;r.path.push(P),r.currentNode=P,u.add(P),r.cost+=b(r.path[r.path.length-2],r.currentNode)}r.cost+=b(r.currentNode,0),r.cost<I&&r.path.length===t.length&&(I=r.cost,S=[...r.path,0])}),c%50==0&&_.toString()===S.toString()&&I<1/0)return{vertices:S,distance:I,paths:N};const d=a.map(r=>{const u=r.path,y=r.cost,f=Array.from({length:t.length},()=>0);for(let w=0;w<u.length-1;w++){const B=u[w+1];f[u[w]]+=100/y,f[B]+=100/y}return f});for(let r=0;r<t.length;r++)for(let u=0;u<t.length;u++)r!==u&&(p[r][u]=.5*p[r][u]+d[r][u]);_=S}return S.length===t.length&&isFinite(I)?{vertices:S,distance:I,paths:N}:null}static solveTravelingSalesmanProblemGA(t){const i=t.length,s=20*i,o=Math.trunc(1e5/i),l=Math.trunc(.1*s),n=t.map(c=>c.map(a=>0===a?1/0:a)),e=c=>{let a=0,d=0;for(let r=0;r<c.length;r++){const u=n[c[r]][c[(r+1)%c.length]];isFinite(1/0)||++a,d+=u}return 1/d/(a+1)},h=(c,a)=>{const d=[...c];if(Math.random()<a){let r=Math.floor(Math.random()*d.length),u=Math.floor(Math.random()*d.length);for(;r===u;)u=Math.floor(Math.random()*d.length);for(u<r&&([r,u]=[u,r]);r<u;)[d[r],d[u]]=[d[u],d[r]],r++,u--}return d},v=(c,a)=>{const d=c.length,r=new Array(d).fill(-1),u=Math.floor(Math.random()*d),y=u+Math.floor(Math.random()*(d-u));for(let f=u;f<=y;f++)r[f]=c[f];for(let f=0;f<d;f++)if(!r.includes(a[f])){let w=f;for(;-1!==r[w];)w=c.indexOf(a[w]);r[w]=a[f]}return r};let g=Array.from({length:s},()=>{const c=Array.from({length:i},(a,d)=>d);for(let a=c.length-1;a>0;a--){const d=Math.floor(Math.random()*(a+1));[c[a],c[d]]=[c[d],c[a]]}return c}),p=0,b=[],I=-1/0,S=0;for(let c=0;c<o;c++){let a=-1/0;g.sort((y,f)=>e(f)-e(y)),S+=g.length;const d=g.slice(0,l),r=[...d],u=(y,f)=>{const w=y.reduce((M,z)=>M+f(z),0),A=Math.random()*w;let P,x,B=0;for(const M of y)if(B+=f(M),!P&&B>=A)P=M;else if(P&&!x&&B>=A){x=M;break}if(!x){const M=y.filter(D=>D!==P);x=M[Math.floor(Math.random()*M.length)]}return[P,x]};for(let y=0;y<s-l;y++){let f=v(...u(d,e));f=h(f,.05),r.push(f);const w=e(f);w>a&&(a=w,b=f)}if(g=r,a>I)I=a,p=0;else if(a>0&&p++>=5)break}const N=(c=b).reduce((a,d,r)=>a+n[d][c[(r+1)%n.length]],0);var c;return isFinite(N)?{vertices:[...b,b[0]],distance:N,paths:S}:null}static solveTravelingSalesmanProblemBaB(t){const i=t.length,s=t.map(n=>n.map(e=>0===e?1/0:e)),o=new F,l=Math.trunc(Math.random()*t.length),m=new R([l],0);for(o.enqueue(m);!o.isEmpty();){const n=o.dequeue();if(n){if(n.vertices.length===i+1)return{vertices:n.vertices,distance:n.distance,paths:o.size};if(n.vertices.length===i&&s[n.vertices[n.vertices.length-1]][l]<1/0){const e=new R([...n.vertices,l],n.distance+s[n.vertices[n.vertices.length-1]][l]);o.enqueue(e)}else if(n.vertices.length<i)for(let e=0;e<i;e++)if(!n.vertices.includes(e)&&s[n.vertices[n.vertices.length-1]][e]<1/0){const h=new R([...n.vertices,e],n.distance+s[n.vertices[n.vertices.length-1]][e]);o.enqueue(h)}}}return null}static solveTravelingSalesmanProblemBaB32(t){const i=t.length,s=t.map(n=>n.map(e=>0===e?1/0:e)),o=new F,l=Math.trunc(Math.random()*t.length),m=new C(l.toString(32),0,1<<l);for(o.enqueue(m);!o.isEmpty();){const n=o.dequeue();if(n){if(n.route.length===i+1)return{vertices:n.route.split("").map(e=>parseInt(e,32)),distance:n.distance,paths:o.size};if(n.route.length===i){const e=parseInt(n.route.charAt(n.route.length-1),32);if(s[e][l]<1/0){const h=new C(n.route+l.toString(32),n.distance+s[e][l],n.bitmask|1<<l);o.enqueue(h)}}else for(let e=0;e<i;e++){const h=parseInt(n.route.charAt(n.route.length-1),32);if(!(n.bitmask&1<<e)&&s[h][e]<1/0){const v=n.route+e.toString(32),p=new C(v,n.distance+s[h][e],n.bitmask|1<<e);o.enqueue(p)}}}}return null}static solveTravelingSalesmanProblemLittle(t){function i(e){const h=[];let v=e.shift()??[-1,-1];for(h.push(v[0]);e.length>0;){const g=e.findIndex(p=>p[0]===v[1]);if(-1===g)break;v=e[g],e.splice(g,1),h.push(v[0])}return h.push(v[1]),h}const s=new k(t.map(e=>e.map(h=>0===h?1/0:h))),o=new E,{matrix:l,lowerBound:m}=s.reduceMatrix(s.matrix);let n=0;for(o.enqueue(new k(l,m));!o.isEmpty();){const e=o.dequeue();if(!e)return null;if(1===e.matrix.length){if(e.path.push([e.indexes.rows[0],e.indexes.cols[0]]),e.lowerBound===1/0)return null;const h=i(e.path);if(h.length!==t.length+1)continue;return{vertices:h,distance:e.lowerBound,paths:n}}{const{penalty:h,maxPenaltyPos:[v,g]}=e.calculatePenalties();if(-1===h)return null;const p=e.transform(v,g);o.enqueue(p),h!==1/0&&(e.blockPath(v,g),e.lowerBound+=h,e.dryReduceMatrix(),o.enqueue(e))}n++}return null}}const j={Ants:T.solveTravelingSalesmanProblemACO,BranchAndBound:T.solveTravelingSalesmanProblemBaB,Genetic:T.solveTravelingSalesmanProblemGA,BranchAndBound32:T.solveTravelingSalesmanProblemBaB32,Little:T.solveTravelingSalesmanProblemLittle};self.onmessage=({data:q})=>{const{method:t,adjacencyMatrix:i}=q,s=j[t];if(s){const o=performance.now(),l=s(i),n=performance.now()-o;self.postMessage({solution:l,timeElapsed:n})}else console.error(`Unknown method: ${t}`)}})();