(()=>{"use strict";class A{constructor(s,o){this.vertices=s,this.distance=o}}class j{constructor(s){this.value=s,this.left=null,this.right=null,this.npl=0}}class E{constructor(){this.root=null}enqueue(s){const o=new j(s);this.root=this.merge(this.root,o)}dequeue(){if(this.isEmpty())return;const s=this.root.value;return this.root=this.merge(this.root.left,this.root.right),s}isEmpty(){return null===this.root}merge(s,o){return s?(o&&(s.value.distance>o.value.distance&&([s,o]=[o,s]),s.right=this.merge(s.right,o),(!s.left||s.left.npl<s.right.npl)&&([s.left,s.right]=[s.right,s.left]),s.npl=s.right?s.right.npl+1:1),s):o}}let k=(()=>{class b{static solveTravelingSalesmanProblemACO(o){const C=o.map(n=>n.map(e=>0===e?1/0:e)),T=1/(o.length*o.length),B=o.reduce((n,e)=>n+e.reduce((i,t)=>i+t,0),0),I=o.map(n=>n.map(e=>T/B*e)),y=(n,e)=>C[n][e];let N=1/0,P=[],q=[];for(let n=0;n<1e3;n++){const e=Array.from({length:100},()=>({path:[0],currentNode:0,cost:0}));if(e.forEach(t=>{const r=new Set(t.path);for(;r.size<o.length;){const f=o[t.currentNode].map((a,m)=>m).filter(a=>!r.has(a)&&y(t.currentNode,a)),c=f.reduce((a,m)=>a+Math.pow(I[t.currentNode][m],1)*Math.pow(1/y(t.currentNode,m),1),0),h=f.map(a=>({dest:a,prob:Math.pow(I[t.currentNode][a],1)*Math.pow(1/y(t.currentNode,a),1)/c}));h.sort((a,m)=>m.prob-a.prob);const F=Math.random();let S=0,M=-1;for(const a of h)if(S+=a.prob,S>=F){M=a.dest;break}if(-1===M)break;t.path.push(M),t.currentNode=M,r.add(M),t.cost+=y(t.path[t.path.length-2],t.currentNode)}t.cost+=y(t.currentNode,0),t.cost<N&&t.path.length===o.length&&(N=t.cost,P=[...t.path,0])}),n%50==0&&q.toString()===P.toString()&&N<1/0)return{vertices:P,distance:N};const i=e.map(t=>{const r=t.path,f=t.cost,c=Array.from({length:o.length},()=>0);for(let h=0;h<r.length-1;h++){const S=r[h+1];c[r[h]]+=100/f,c[S]+=100/f}return c});for(let t=0;t<o.length;t++)for(let r=0;r<o.length;r++)t!==r&&(I[t][r]=.5*I[t][r]+i[t][r]);q=P}return P.length===o.length&&isFinite(N)?{vertices:P,distance:N}:null}static solveTravelingSalesmanProblemGA(o){const v=o.length,g=20*v,d=Math.trunc(1e5/v),p=Math.trunc(.1*g),l=o.map(n=>n.map(e=>0===e?1/0:e)),u=n=>{let e=0,i=0;for(let t=0;t<n.length;t++){const r=l[n[t]][n[(t+1)%n.length]];isFinite(1/0)||++e,i+=r}return 1/i/(e+1)},C=(n,e)=>{const i=[...n];if(Math.random()<e){let t=Math.floor(Math.random()*i.length),r=Math.floor(Math.random()*i.length);for(;t===r;)r=Math.floor(Math.random()*i.length);for(r<t&&([t,r]=[r,t]);t<r;)[i[t],i[r]]=[i[r],i[t]],t++,r--}return i},T=(n,e)=>{const i=n.length,t=new Array(i).fill(-1),r=Math.floor(Math.random()*i),f=r+Math.floor(Math.random()*(i-r));for(let c=r;c<=f;c++)t[c]=n[c];for(let c=0;c<i;c++)if(!t.includes(e[c])){let h=c;for(;-1!==t[h];)h=n.indexOf(e[h]);t[h]=e[c]}return t};let B=Array.from({length:g},()=>{const n=Array.from({length:v},(e,i)=>i);for(let e=n.length-1;e>0;e--){const i=Math.floor(Math.random()*(e+1));[n[e],n[i]]=[n[i],n[e]]}return n}),I=0,y=[],N=-1/0;for(let n=0;n<d;n++){let e=-1/0;B.sort((f,c)=>u(c)-u(f));const i=B.slice(0,p),t=[...i],r=(f,c)=>{const h=f.reduce((m,x)=>m+c(x),0),F=Math.random()*h;let M,a,S=0;for(const m of f)if(S+=c(m),!M&&S>=F)M=m;else if(M&&!a&&S>=F){a=m;break}if(!a){const m=f.filter(z=>z!==M);a=m[Math.floor(Math.random()*m.length)]}return[M,a]};for(let f=0;f<g-p;f++){let c=T(...r(i,u));c=C(c,.05),t.push(c);const h=u(c);h>e&&(e=h,y=c)}if(B=t,e>N)N=e,I=0;else if(e>0&&I++>=5)break}const q=(n=y).reduce((e,i,t)=>e+l[i][n[(t+1)%l.length]],0);var n;return isFinite(q)?{vertices:[...y,y[0]],distance:q}:null}static solveTravelingSalesmanProblemBaB(o){const v=o.length,g=o.map(l=>l.map(u=>0===u?b.INF:u)),d=new E,p=Math.trunc(Math.random()*o.length),w=new A([p],0);for(d.enqueue(w);!d.isEmpty();){const l=d.dequeue();if(l){if(l.vertices.length===v+1)return{vertices:l.vertices,distance:l.distance};if(l.vertices.length===v&&g[l.vertices[l.vertices.length-1]][p]<b.INF){const u=new A([...l.vertices,p],l.distance+g[l.vertices[l.vertices.length-1]][p]);d.enqueue(u)}else for(let u=0;u<v;u++)if(!l.vertices.includes(u)&&g[l.vertices[l.vertices.length-1]][u]<b.INF){const C=new A([...l.vertices,u],l.distance+g[l.vertices[l.vertices.length-1]][u]);d.enqueue(C)}}}return null}static calculateLowerBound(o,v){let g=0;for(let d=0;d<o.length;d++)if(!v.includes(d)){let p=b.INF;for(let w=0;w<o.length;w++)p=Math.min(p,o[d][w]);g+=p}return g}}return b.INF=1e9,b})();const D={Ants:k.solveTravelingSalesmanProblemACO,BranchAndBound:k.solveTravelingSalesmanProblemBaB,Genetic:k.solveTravelingSalesmanProblemGA};self.onmessage=({data:b})=>{const{method:s,adjacencyMatrix:o}=b,v=D[s];if(v){const g=performance.now(),d=v(o),w=performance.now()-g;self.postMessage({solution:d,timeElapsed:w})}else console.error(`Unknown method: ${s}`)}})();