(()=>{"use strict";class P{static rowReduction(t){const n=[],o=t.map(i=>{const l=Math.min(...i);return n.push(l),i.map(d=>d!==1/0?d-l:d)});return{redux:n,matrix:o}}static columnReduction(t){const n=t.map((l,d)=>t.map(u=>u[d])),o=P.rowReduction(n),i=o.matrix[0].map((l,d)=>o.matrix.map(u=>u[d]));return{redux:o.redux,matrix:i}}static reduceMatrix(t){const n=P.rowReduction(t),o=P.columnReduction(n.matrix);return{matrix:o.matrix,lowerBound:[...n.redux,...o.redux].reduce((i,l)=>i+l,0)}}get isScalar(){return 1===this.matrix.length}get valid(){return this.lowerBound!==1/0}get distance(){return this.lowerBound}constructor(t,n=0,o={rows:Array.from({length:t.length}).map((l,d)=>d),cols:Array.from({length:t.length}).map((l,d)=>d)},i=[]){this.matrix=t,this.lowerBound=n,this.indexes=o,this.path=i}compareTo(t){return this.lowerBound-t.lowerBound}restorePath(){const t=[],n=[...this.path,[this.indexes.rows[0],this.indexes.cols[0]]];let o=n.shift()??[-1,-1];for(t.push(o[0]);n.length>0;){const i=n.findIndex(l=>l[0]===o[1]);if(-1===i)break;o=n[i],n.splice(i,1),t.push(o[0])}return t.push(o[1]),t}dryReduceMatrix(t,n,o){this.blockPath(t,n),this.lowerBound+=o;const{matrix:i}=P.reduceMatrix(this.matrix);this.matrix=i}transform(t,n){const o=this.indexes.rows.indexOf(t),i=this.indexes.cols.indexOf(n),l=this.matrix.map(y=>[...y]),d=this.indexes.cols.indexOf(t),u=this.indexes.rows.indexOf(n);-1!==d&&-1!==u&&(l[u][d]=1/0);const m=l.filter((y,w)=>w!==o).map(y=>y.filter((w,v)=>v!==i)),{matrix:M,lowerBound:A}=P.reduceMatrix(m);return new P(M,this.lowerBound+A,{rows:this.indexes.rows.filter((y,w)=>w!==o),cols:this.indexes.cols.filter((y,w)=>w!==i)},[...this.path,[t,n]])}calculatePenalties(){let n,t=-1/0;const o=Array(this.matrix.length).fill(0).map(()=>Array(this.matrix.length).fill(0));for(let i=0;i<this.matrix.length;i++)for(let l=0;l<this.matrix[i].length;l++)if(0===this.matrix[i][l]){const d=Math.min(...this.matrix[i].filter((m,M)=>M!==l&&m!==1/0)),u=Math.min(...this.matrix.map((m,M)=>M!==i&&m[l]!==1/0?m[l]:1/0));o[i][l]=d+u,o[i][l]>=t&&(t=o[i][l],n=[i,l])}return n?{penalty:t,maxPenaltyPos:[this.indexes.rows[n[0]],this.indexes.cols[n[1]]]}:{penalty:-1,maxPenaltyPos:[-1,-1]}}blockPath(t,n){const o=this.indexes.rows.indexOf(t),i=this.indexes.cols.indexOf(n);-1!==i&&-1!==o&&(this.matrix[o][i]=1/0)}}class F{constructor(t){this.value=t,this.left=null,this.right=null,this.npl=0}compareTo(t){return this.value.compareTo(t.value)}}class _{constructor(){this.root=null}enqueue(t){this.root=this.merge(this.root,new F(t))}dequeue(){if(!this.root)return;const t=this.root.value;return this.root=this.merge(this.root.left,this.root.right),t}isEmpty(){return null===this.root}merge(t,n){return t?(n&&(t.compareTo(n)>0&&([t,n]=[n,t]),t.right=this.merge(t.right,n),(!t.left||t.right&&t.left.npl<t.right.npl)&&([t.left,t.right]=[t.right,t.left]),t.npl=t.right?t.right.npl+1:1),t):n}}class k{static solveTravelingSalesmanProblemACO(t){const n=10*t.length,M=t.map(s=>s.map(r=>0===r?1/0:r)),A=1/(t.length*t.length),y=t.reduce((s,r)=>s+r.reduce((c,e)=>c+e,0),0),w=t.map(s=>s.map(r=>A/y*r)),v=(s,r)=>M[s][r];let I=1/0,S=[],B=[],C=0;for(let s=0;s<1e4;s++){const r=Array.from({length:n},()=>({path:[0],currentNode:0,cost:0}));if(r.forEach(e=>{C++;const a=new Set(e.path);for(;a.size<t.length;){const x=t[e.currentNode].map((f,g)=>g).filter(f=>!a.has(f)&&v(e.currentNode,f)),h=x.reduce((f,g)=>f+Math.pow(w[e.currentNode][g],1)*Math.pow(1/v(e.currentNode,g),1),0),p=x.map(f=>({dest:f,prob:Math.pow(w[e.currentNode][f],1)*Math.pow(1/v(e.currentNode,f),1)/h}));p.sort((f,g)=>g.prob-f.prob);const R=Math.random();let N=0,b=-1;for(const f of p)if(N+=f.prob,N>=R){b=f.dest;break}if(-1===b)break;e.path.push(b),e.currentNode=b,a.add(b),e.cost+=v(e.path[e.path.length-2],e.currentNode)}e.cost+=v(e.currentNode,0),e.cost<I&&e.path.length===t.length&&(I=e.cost,S=[...e.path,0])}),s%50==0&&B.toString()===S.toString()&&I<1/0)return{vertices:S,distance:I,paths:C};const c=r.map(e=>{const a=e.path,x=e.cost,h=Array.from({length:t.length},()=>0);for(let p=0;p<a.length-1;p++){const N=a[p+1];h[a[p]]+=100/x,h[N]+=100/x}return h});for(let e=0;e<t.length;e++)for(let a=0;a<t.length;a++)e!==a&&(w[e][a]=.5*w[e][a]+c[e][a]);B=S}return S.length===t.length&&isFinite(I)?{vertices:S,distance:I,paths:C}:null}static solveTravelingSalesmanProblemGA(t){const n=t.length,o=20*n,i=Math.trunc(1e5/n),l=Math.trunc(.1*o),u=t.map(s=>s.map(r=>0===r?1/0:r)),m=s=>{let r=0,c=0;for(let e=0;e<s.length;e++){const a=u[s[e]][s[(e+1)%s.length]];isFinite(1/0)||++r,c+=a}return 1/c/(r+1)},M=(s,r)=>{const c=[...s];if(Math.random()<r){let e=Math.floor(Math.random()*c.length),a=Math.floor(Math.random()*c.length);for(;e===a;)a=Math.floor(Math.random()*c.length);for(a<e&&([e,a]=[a,e]);e<a;)[c[e],c[a]]=[c[a],c[e]],e++,a--}return c},A=(s,r)=>{const c=s.length,e=new Array(c).fill(-1),a=Math.floor(Math.random()*c),x=a+Math.floor(Math.random()*(c-a));for(let h=a;h<=x;h++)e[h]=s[h];for(let h=0;h<c;h++)if(!e.includes(r[h])){let p=h;for(;-1!==e[p];)p=s.indexOf(r[p]);e[p]=r[h]}return e};let y=Array.from({length:o},()=>{const s=Array.from({length:n},(r,c)=>c);for(let r=s.length-1;r>0;r--){const c=Math.floor(Math.random()*(r+1));[s[r],s[c]]=[s[c],s[r]]}return s}),w=0,v=[],I=-1/0,S=0;for(let s=0;s<i;s++){let r=-1/0;y.sort((x,h)=>m(h)-m(x)),S+=y.length;const c=y.slice(0,l),e=[...c],a=(x,h)=>{const p=x.reduce((g,O)=>g+h(O),0),R=Math.random()*p;let b,f,N=0;for(const g of x)if(N+=h(g),!b&&N>=R)b=g;else if(b&&!f&&N>=R){f=g;break}if(!f){const g=x.filter(j=>j!==b);f=g[Math.floor(Math.random()*g.length)]}return[b,f]};for(let x=0;x<o-l;x++){let h=A(...a(c,m));h=M(h,.05),e.push(h);const p=m(h);p>r&&(r=p,v=h)}if(y=e,r>I)I=r,w=0;else if(r>0&&w++>=5)break}const C=(s=v).reduce((r,c,e)=>r+u[c][s[(e+1)%u.length]],0);var s;return isFinite(C)?{vertices:[...v,v[0]],distance:C,paths:S}:null}static solveTravelingSalesmanProblemLittle(t){const n=t.map(u=>u.map(m=>0===m?1/0:m)),o=new _,{matrix:i,lowerBound:l}=P.reduceMatrix(n);let d=0;for(o.enqueue(new P(i,l));!o.isEmpty();){const u=o.dequeue();if(!u)return null;if(u.isScalar){if(!u.valid)return null;const m=u.restorePath();if(m.length===t.length+1)return{vertices:m,distance:u.distance,paths:d}}else{const{penalty:m,maxPenaltyPos:[M,A]}=u.calculatePenalties();if(-1===m)return null;o.enqueue(u.transform(M,A)),m!==1/0&&(u.dryReduceMatrix(M,A,m),o.enqueue(u))}d++}return null}}const q={Ants:k.solveTravelingSalesmanProblemACO,Genetic:k.solveTravelingSalesmanProblemGA,Little:k.solveTravelingSalesmanProblemLittle};self.onmessage=({data:T})=>{const{method:t,adjacencyMatrix:n}=T,o=q[t];if(o){const i=performance.now(),l=o(n),u=performance.now()-i;self.postMessage({solution:l,timeElapsed:u})}else console.error(`Unknown method: ${t}`)}})();