(()=>{"use strict";class C{constructor(t,o,s){this.route=t,this.distance=o,this.bitmask=s,this.left=null,this.right=null,this.npl=0}compareTo(t){return this.distance!==t.distance?this.distance-t.distance:t.route.length-this.route.length}}class _{constructor(t,o){this.vertices=t,this.distance=o,this.left=null,this.right=null,this.npl=0}compareTo(t){return this.distance!==t.distance?this.distance-t.distance:t.vertices.length-this.vertices.length}}class F{constructor(){this.size=0,this.root=null}enqueue(t){this.size++,this.root=this.merge(this.root,t)}dequeue(){if(!this.root)return;const t=this.root;return this.root=this.merge(this.root.left,this.root.right),t.left=null,t.right=null,t}isEmpty(){return null===this.root}merge(t,o){return t?(o&&(t.compareTo(o)>0&&([t,o]=[o,t]),t.right=this.merge(t.right,o),(!t.left||t.right&&t.left.npl<t.right.npl)&&([t.left,t.right]=[t.right,t.left]),t.npl=t.right?t.right.npl+1:1),t):o}}class k{constructor(t,o=0,s={rows:Array.from({length:t.length}).map((l,m)=>m),cols:Array.from({length:t.length}).map((l,m)=>m)},r=[]){this.matrix=t,this.lowerBound=o,this.indexes=s,this.path=r}blockPath(t,o){const s=this.indexes.rows.indexOf(t),r=this.indexes.cols.indexOf(o);-1!==r&&-1!==s&&(this.matrix[s][r]=1/0)}transform(t,o){const s=this.indexes.rows.indexOf(t),r=this.indexes.cols.indexOf(o),l=this.matrix.map(g=>[...g]),m=this.indexes.cols.indexOf(t),n=this.indexes.rows.indexOf(o);-1!==m&&-1!==n&&(l[n][m]=1/0);const e=l.filter((g,p)=>p!==s).map(g=>g.filter((p,M)=>M!==r)),{matrix:d,lowerBound:v}=this.reduceMatrix(e);return new k(d,this.lowerBound+v,{rows:this.indexes.rows.filter((g,p)=>p!==s),cols:this.indexes.cols.filter((g,p)=>p!==r)},[...this.path,[t,o]])}calculatePenalties(){let t=-1/0,o=[-1,-1];const s=Array(this.matrix.length).fill(0).map(()=>Array(this.matrix.length).fill(0));for(let r=0;r<this.matrix.length;r++)for(let l=0;l<this.matrix[r].length;l++)if(0===this.matrix[r][l]){const m=Math.min(...this.matrix[r].filter((e,d)=>d!==l&&e!==1/0)),n=Math.min(...this.matrix.map((e,d)=>d!==r&&e[l]!==1/0?e[l]:1/0));s[r][l]=m+n,s[r][l]>=t&&(t=s[r][l],o=[r,l])}return{penalty:t,maxPenaltyPos:[this.indexes.rows[o[0]],this.indexes.cols[o[1]]]}}reduceMatrix(t){const o=this.rowReduction(t),s=this.columnReduction(o.matrix);return{matrix:s.matrix,lowerBound:[...o.redux,...s.redux].reduce((r,l)=>r+l,0)}}rowReduction(t){const o=[],s=t.map(r=>{const l=Math.min(...r);return o.push(l),r.map(m=>m!==1/0?m-l:m)});return{redux:o,matrix:s}}columnReduction(t){const o=t.map((l,m)=>t.map(n=>n[m])),s=this.rowReduction(o),r=s.matrix[0].map((l,m)=>s.matrix.map(n=>n[m]));return{redux:s.redux,matrix:r}}}class O{constructor(t){this.value=t,this.left=null,this.npl=0,this.right=null}compareTo(t){return this.value.lowerBound-t.value.lowerBound}}class E{constructor(){this.size=0,this.root=null}enqueue(t){this.size++,this.root=this.merge(this.root,new O(t))}dequeue(){if(!this.root)return;const t=this.root;return this.root=this.merge(this.root.left,this.root.right),t.left=null,t.right=null,t.value}isEmpty(){return null===this.root}merge(t,o){return t?(o&&(t.compareTo(o)>0&&([t,o]=[o,t]),t.right=this.merge(t.right,o),(!t.left||t.right&&t.left.npl<t.right.npl)&&([t.left,t.right]=[t.right,t.left]),t.npl=t.right?t.right.npl+1:1),t):o}}class T{static solveTravelingSalesmanProblemACO(t){const d=t.map(c=>c.map(a=>0===a?1/0:a)),v=1/(t.length*t.length),g=t.reduce((c,a)=>c+a.reduce((h,i)=>h+i,0),0),p=t.map(c=>c.map(a=>v/g*a)),M=(c,a)=>d[c][a];let P=1/0,S=[],R=[],N=0;for(let c=0;c<1e4;c++){const a=Array.from({length:100},()=>({path:[0],currentNode:0,cost:0}));if(a.forEach(i=>{N++;const u=new Set(i.path);for(;u.size<t.length;){const y=t[i.currentNode].map((w,b)=>b).filter(w=>!u.has(w)&&M(i.currentNode,w)),f=y.reduce((w,b)=>w+Math.pow(p[i.currentNode][b],1)*Math.pow(1/M(i.currentNode,b),1),0),x=y.map(w=>({dest:w,prob:Math.pow(p[i.currentNode][w],1)*Math.pow(1/M(i.currentNode,w),1)/f}));x.sort((w,b)=>b.prob-w.prob);const A=Math.random();let B=0,I=-1;for(const w of x)if(B+=w.prob,B>=A){I=w.dest;break}if(-1===I)break;i.path.push(I),i.currentNode=I,u.add(I),i.cost+=M(i.path[i.path.length-2],i.currentNode)}i.cost+=M(i.currentNode,0),i.cost<P&&i.path.length===t.length&&(P=i.cost,S=[...i.path,0])}),c%50==0&&R.toString()===S.toString()&&P<1/0)return{vertices:S,distance:P,paths:N};const h=a.map(i=>{const u=i.path,y=i.cost,f=Array.from({length:t.length},()=>0);for(let x=0;x<u.length-1;x++){const B=u[x+1];f[u[x]]+=100/y,f[B]+=100/y}return f});for(let i=0;i<t.length;i++)for(let u=0;u<t.length;u++)i!==u&&(p[i][u]=.5*p[i][u]+h[i][u]);R=S}return S.length===t.length&&isFinite(P)?{vertices:S,distance:P,paths:N}:null}static solveTravelingSalesmanProblemGA(t){const o=t.length,s=20*o,r=Math.trunc(1e5/o),l=Math.trunc(.1*s),n=t.map(c=>c.map(a=>0===a?1/0:a)),e=c=>{let a=0,h=0;for(let i=0;i<c.length;i++){const u=n[c[i]][c[(i+1)%c.length]];isFinite(1/0)||++a,h+=u}return 1/h/(a+1)},d=(c,a)=>{const h=[...c];if(Math.random()<a){let i=Math.floor(Math.random()*h.length),u=Math.floor(Math.random()*h.length);for(;i===u;)u=Math.floor(Math.random()*h.length);for(u<i&&([i,u]=[u,i]);i<u;)[h[i],h[u]]=[h[u],h[i]],i++,u--}return h},v=(c,a)=>{const h=c.length,i=new Array(h).fill(-1),u=Math.floor(Math.random()*h),y=u+Math.floor(Math.random()*(h-u));for(let f=u;f<=y;f++)i[f]=c[f];for(let f=0;f<h;f++)if(!i.includes(a[f])){let x=f;for(;-1!==i[x];)x=c.indexOf(a[x]);i[x]=a[f]}return i};let g=Array.from({length:s},()=>{const c=Array.from({length:o},(a,h)=>h);for(let a=c.length-1;a>0;a--){const h=Math.floor(Math.random()*(a+1));[c[a],c[h]]=[c[h],c[a]]}return c}),p=0,M=[],P=-1/0,S=0;for(let c=0;c<r;c++){let a=-1/0;g.sort((y,f)=>e(f)-e(y)),S+=g.length;const h=g.slice(0,l),i=[...h],u=(y,f)=>{const x=y.reduce((b,z)=>b+f(z),0),A=Math.random()*x;let I,w,B=0;for(const b of y)if(B+=f(b),!I&&B>=A)I=b;else if(I&&!w&&B>=A){w=b;break}if(!w){const b=y.filter(D=>D!==I);w=b[Math.floor(Math.random()*b.length)]}return[I,w]};for(let y=0;y<s-l;y++){let f=v(...u(h,e));f=d(f,.05),i.push(f);const x=e(f);x>a&&(a=x,M=f)}if(g=i,a>P)P=a,p=0;else if(a>0&&p++>=5)break}const N=(c=M).reduce((a,h,i)=>a+n[h][c[(i+1)%n.length]],0);var c;return isFinite(N)?{vertices:[...M,M[0]],distance:N,paths:S}:null}static solveTravelingSalesmanProblemBaB(t){const o=t.length,s=t.map(n=>n.map(e=>0===e?1/0:e)),r=new F,l=Math.trunc(Math.random()*t.length),m=new _([l],0);for(r.enqueue(m);!r.isEmpty();){const n=r.dequeue();if(n){if(n.vertices.length===o+1)return{vertices:n.vertices,distance:n.distance,paths:r.size};if(n.vertices.length===o&&s[n.vertices[n.vertices.length-1]][l]<1/0){const e=new _([...n.vertices,l],n.distance+s[n.vertices[n.vertices.length-1]][l]);r.enqueue(e)}else if(n.vertices.length<o)for(let e=0;e<o;e++)if(!n.vertices.includes(e)&&s[n.vertices[n.vertices.length-1]][e]<1/0){const d=new _([...n.vertices,e],n.distance+s[n.vertices[n.vertices.length-1]][e]);r.enqueue(d)}}}return null}static solveTravelingSalesmanProblemBaB32(t){const o=t.length,s=t.map(n=>n.map(e=>0===e?1/0:e)),r=new F,l=Math.trunc(Math.random()*t.length),m=new C(l.toString(32),0,1<<l);for(r.enqueue(m);!r.isEmpty();){const n=r.dequeue();if(n){if(n.route.length===o+1)return{vertices:n.route.split("").map(e=>parseInt(e,32)),distance:n.distance,paths:r.size};if(n.route.length===o){const e=parseInt(n.route.charAt(n.route.length-1),32);if(s[e][l]<1/0){const d=new C(n.route+l.toString(32),n.distance+s[e][l],n.bitmask|1<<l);r.enqueue(d)}}else for(let e=0;e<o;e++){const d=parseInt(n.route.charAt(n.route.length-1),32);if(!(n.bitmask&1<<e)&&s[d][e]<1/0){const v=n.route+e.toString(32),p=new C(v,n.distance+s[d][e],n.bitmask|1<<e);r.enqueue(p)}}}}return null}static solveTravelingSalesmanProblemLittle(t){function o(e){const d=[];let v=e.shift()??[-1,-1];for(d.push(v[0]);e.length>0;){const g=e.findIndex(p=>p[0]===v[1]);if(-1===g)break;v=e[g],e.splice(g,1),d.push(v[0])}return d.push(v[1]),d}const s=new k(t.map(e=>e.map(d=>0===d?1/0:d))),r=new E,{matrix:l,lowerBound:m}=s.reduceMatrix(s.matrix);let n=0;for(r.enqueue(new k(l,m));!r.isEmpty();){const e=r.dequeue();if(!e)return null;if(1===e.matrix.length)return e.path.push([e.indexes.rows[0],e.indexes.cols[0]]),e.lowerBound===1/0?null:{vertices:o(e.path),distance:e.lowerBound,paths:n};{const{penalty:d,maxPenaltyPos:[v,g]}=e.calculatePenalties(),p=e.transform(v,g);r.enqueue(p),d!==1/0&&(e.blockPath(v,g),e.lowerBound+=d,r.enqueue(e))}n++}return null}}const j={Ants:T.solveTravelingSalesmanProblemACO,BranchAndBound:T.solveTravelingSalesmanProblemBaB,Genetic:T.solveTravelingSalesmanProblemGA,BranchAndBound32:T.solveTravelingSalesmanProblemBaB32,Little:T.solveTravelingSalesmanProblemLittle};self.onmessage=({data:q})=>{const{method:t,adjacencyMatrix:o}=q,s=j[t];if(s){const r=performance.now(),l=s(o),n=performance.now()-r;self.postMessage({solution:l,timeElapsed:n})}else console.error(`Unknown method: ${t}`)}})();