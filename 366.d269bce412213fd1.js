(()=>{"use strict";class T{constructor(e,l){this.left=null,this.right=null,this.npl=0,this.vertices=e,this.distance=l}compareTo(e){return this.distance!==e.distance?this.distance-e.distance:e.vertices.length-this.vertices.length}}class x{constructor(){this.size=0,this.root=null}enqueue(e){this.size++,this.root=this.merge(this.root,e)}dequeue(){if(this.isEmpty())return;const e=this.root;return this.root=this.merge(this.root.left,this.root.right),e}isEmpty(){return null===this.root}merge(e,l){return e?(l&&(e.compareTo(l)>0&&([e,l]=[l,e]),e.right=this.merge(e.right,l),(!e.left||e.left.npl<e.right.npl)&&([e.left,e.right]=[e.right,e.left]),e.npl=e.right?e.right.npl+1:1),e):l}}class q{static solveTravelingSalesmanProblemACO(e){const N=e.map(o=>o.map(n=>0===n?1/0:n)),k=1/(e.length*e.length),A=e.reduce((o,n)=>o+n.reduce((r,t)=>r+t,0),0),w=e.map(o=>o.map(n=>k/A*n)),b=(o,n)=>N[o][n];let y=1/0,S=[],C=[];for(let o=0;o<1e3;o++){const n=Array.from({length:100},()=>({path:[0],currentNode:0,cost:0}));if(n.forEach(t=>{const i=new Set(t.path);for(;i.size<e.length;){const f=e[t.currentNode].map((a,d)=>d).filter(a=>!i.has(a)&&b(t.currentNode,a)),c=f.reduce((a,d)=>a+Math.pow(w[t.currentNode][d],1)*Math.pow(1/b(t.currentNode,d),1),0),u=f.map(a=>({dest:a,prob:Math.pow(w[t.currentNode][a],1)*Math.pow(1/b(t.currentNode,a),1)/c}));u.sort((a,d)=>d.prob-a.prob);const I=Math.random();let M=0,g=-1;for(const a of u)if(M+=a.prob,M>=I){g=a.dest;break}if(-1===g)break;t.path.push(g),t.currentNode=g,i.add(g),t.cost+=b(t.path[t.path.length-2],t.currentNode)}t.cost+=b(t.currentNode,0),t.cost<y&&t.path.length===e.length&&(y=t.cost,S=[...t.path,0])}),o%50==0&&C.toString()===S.toString()&&y<1/0)return{vertices:S,distance:y};const r=n.map(t=>{const i=t.path,f=t.cost,c=Array.from({length:e.length},()=>0);for(let u=0;u<i.length-1;u++){const M=i[u+1];c[i[u]]+=100/f,c[M]+=100/f}return c});for(let t=0;t<e.length;t++)for(let i=0;i<e.length;i++)t!==i&&(w[t][i]=.5*w[t][i]+r[t][i]);C=S}return S.length===e.length&&isFinite(y)?{vertices:S,distance:y}:null}static solveTravelingSalesmanProblemGA(e){const l=e.length,m=20*l,v=Math.trunc(1e5/l),p=Math.trunc(.1*m),s=e.map(o=>o.map(n=>0===n?1/0:n)),h=o=>{let n=0,r=0;for(let t=0;t<o.length;t++){const i=s[o[t]][o[(t+1)%o.length]];isFinite(1/0)||++n,r+=i}return 1/r/(n+1)},N=(o,n)=>{const r=[...o];if(Math.random()<n){let t=Math.floor(Math.random()*r.length),i=Math.floor(Math.random()*r.length);for(;t===i;)i=Math.floor(Math.random()*r.length);for(i<t&&([t,i]=[i,t]);t<i;)[r[t],r[i]]=[r[i],r[t]],t++,i--}return r},k=(o,n)=>{const r=o.length,t=new Array(r).fill(-1),i=Math.floor(Math.random()*r),f=i+Math.floor(Math.random()*(r-i));for(let c=i;c<=f;c++)t[c]=o[c];for(let c=0;c<r;c++)if(!t.includes(n[c])){let u=c;for(;-1!==t[u];)u=o.indexOf(n[u]);t[u]=n[c]}return t};let A=Array.from({length:m},()=>{const o=Array.from({length:l},(n,r)=>r);for(let n=o.length-1;n>0;n--){const r=Math.floor(Math.random()*(n+1));[o[n],o[r]]=[o[r],o[n]]}return o}),w=0,b=[],y=-1/0;for(let o=0;o<v;o++){let n=-1/0;A.sort((f,c)=>h(c)-h(f));const r=A.slice(0,p),t=[...r],i=(f,c)=>{const u=f.reduce((d,B)=>d+c(B),0),I=Math.random()*u;let g,a,M=0;for(const d of f)if(M+=c(d),!g&&M>=I)g=d;else if(g&&!a&&M>=I){a=d;break}if(!a){const d=f.filter(z=>z!==g);a=d[Math.floor(Math.random()*d.length)]}return[g,a]};for(let f=0;f<m-p;f++){let c=k(...i(r,h));c=N(c,.05),t.push(c);const u=h(c);u>n&&(n=u,b=c)}if(A=t,n>y)y=n,w=0;else if(n>0&&w++>=5)break}const C=(o=b).reduce((n,r,t)=>n+s[r][o[(t+1)%s.length]],0);var o;return isFinite(C)?{vertices:[...b,b[0]],distance:C}:null}static solveTravelingSalesmanProblemBaB(e){const l=e.length,m=e.map(s=>s.map(h=>0===h?1/0:h)),v=new x,p=Math.trunc(Math.random()*e.length),P=new T([p],0);for(v.enqueue(P);!v.isEmpty();){const s=v.dequeue();if(s){if(s.vertices.length===l+1)return{vertices:s.vertices,distance:s.distance};if(s.vertices.length===l&&m[s.vertices[s.vertices.length-1]][p]<1/0){const h=new T([...s.vertices,p],s.distance+m[s.vertices[s.vertices.length-1]][p]);v.enqueue(h)}else if(s.vertices.length<l)for(let h=0;h<l;h++)if(!s.vertices.includes(h)&&m[s.vertices[s.vertices.length-1]][h]<1/0){const N=new T([...s.vertices,h],s.distance+m[s.vertices[s.vertices.length-1]][h]);v.enqueue(N)}}}return null}}const _={Ants:q.solveTravelingSalesmanProblemACO,BranchAndBound:q.solveTravelingSalesmanProblemBaB,Genetic:q.solveTravelingSalesmanProblemGA};self.onmessage=({data:F})=>{const{method:e,adjacencyMatrix:l}=F,m=_[e];if(m){const v=performance.now(),p=m(l),s=performance.now()-v;self.postMessage({solution:p,timeElapsed:s})}else console.error(`Unknown method: ${e}`)}})();